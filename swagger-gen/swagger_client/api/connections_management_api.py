# coding: utf-8

"""
    Open Enterprise Agent API Reference

     The Open Enterprise Agent API facilitates the integration and management of self-sovereign identity capabilities within applications. It supports DID (Decentralized Identifiers) management, verifiable credential exchange, and secure messaging based on DIDComm standards. The API is designed to be interoperable with various blockchain and DLT (Distributed Ledger Technology) platforms, ensuring wide compatibility and flexibility. Key features include connection management, credential issuance and verification, and secure, privacy-preserving communication between entities. Additional information and the full list of capabilities can be found in the [Open Enterprise Agent documentation](https://docs.atalaprism.io/docs/category/prism-cloud-agent)   # noqa: E501

    OpenAPI spec version: 1.31.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ConnectionsManagementApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accept_connection_invitation(self, body, **kwargs):  # noqa: E501
        """Accept a new connection invitation received out-of-band from another peer Agent.  # noqa: E501

         Accept an new connection invitation received out-of-band from another peer Agent. The invitation must be compliant with the DIDComm Messaging v2.0 - [Out of Band Messages](https://identity.foundation/didcomm-messaging/spec/v2.0/#out-of-band-messages) specification [section 9.5.4](https://identity.foundation/didcomm-messaging/spec/v2.0/#invitation). A new connection record with state `ConnectionRequestPending` will be created in the agent database and later processed by a background job to send a connection request to the peer Agent. The created record will contain a newly generated pairwise Peer DID used for that connection. A connection request will then be sent to the peer Agent to actually establish the connection, moving the record state to `ConnectionRequestSent`, and waiting the connection response from the peer Agent.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accept_connection_invitation(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AcceptConnectionInvitationRequest body: The request used by an invitee to accept a connection invitation received from an inviter, using out-of-band mechanism. (required)
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accept_connection_invitation_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.accept_connection_invitation_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def accept_connection_invitation_with_http_info(self, body, **kwargs):  # noqa: E501
        """Accept a new connection invitation received out-of-band from another peer Agent.  # noqa: E501

         Accept an new connection invitation received out-of-band from another peer Agent. The invitation must be compliant with the DIDComm Messaging v2.0 - [Out of Band Messages](https://identity.foundation/didcomm-messaging/spec/v2.0/#out-of-band-messages) specification [section 9.5.4](https://identity.foundation/didcomm-messaging/spec/v2.0/#invitation). A new connection record with state `ConnectionRequestPending` will be created in the agent database and later processed by a background job to send a connection request to the peer Agent. The created record will contain a newly generated pairwise Peer DID used for that connection. A connection request will then be sent to the peer Agent to actually establish the connection, moving the record state to `ConnectionRequestSent`, and waiting the connection response from the peer Agent.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accept_connection_invitation_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AcceptConnectionInvitationRequest body: The request used by an invitee to accept a connection invitation received from an inviter, using out-of-band mechanism. (required)
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accept_connection_invitation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `accept_connection_invitation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyAuth', 'jwtAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connection-invitations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_connection(self, body, **kwargs):  # noqa: E501
        """Create a new connection invitation that can be delivered out-of-band to a peer Agent.  # noqa: E501

         Create a new connection invitation that can be delivered out-of-band to a peer Agent, regardless of whether it resides in Cloud Agent or edge environment. The generated invitation adheres to the DIDComm Messaging v2.0 - [Out of Band Messages](https://identity.foundation/didcomm-messaging/spec/v2.0/#out-of-band-messages) specification [section 9.5.4](https://identity.foundation/didcomm-messaging/spec/v2.0/#invitation). The <b>from</b> field of the out-of-band invitation message contains a freshly generated Peer DID that complies with the [did:peer:2](https://identity.foundation/peer-did-method-spec/#generating-a-didpeer2) specification. This Peer DID includes the 'uri' location of the DIDComm messaging service, essential for the invitee's subsequent execution of the connection flow. In the Agent database, the created connection record has an initial state set to `InvitationGenerated`. The request body may contain a `label` that can be used as a human readable alias for the connection, for example `{'label': \"Connection with Bob\"}`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_connection(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateConnectionRequest body: JSON object required for the connection creation. (required)
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_connection_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_connection_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_connection_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new connection invitation that can be delivered out-of-band to a peer Agent.  # noqa: E501

         Create a new connection invitation that can be delivered out-of-band to a peer Agent, regardless of whether it resides in Cloud Agent or edge environment. The generated invitation adheres to the DIDComm Messaging v2.0 - [Out of Band Messages](https://identity.foundation/didcomm-messaging/spec/v2.0/#out-of-band-messages) specification [section 9.5.4](https://identity.foundation/didcomm-messaging/spec/v2.0/#invitation). The <b>from</b> field of the out-of-band invitation message contains a freshly generated Peer DID that complies with the [did:peer:2](https://identity.foundation/peer-did-method-spec/#generating-a-didpeer2) specification. This Peer DID includes the 'uri' location of the DIDComm messaging service, essential for the invitee's subsequent execution of the connection flow. In the Agent database, the created connection record has an initial state set to `InvitationGenerated`. The request body may contain a `label` that can be used as a human readable alias for the connection, for example `{'label': \"Connection with Bob\"}`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_connection_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateConnectionRequest body: JSON object required for the connection creation. (required)
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_connection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_connection`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyAuth', 'jwtAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_connection(self, connection_id, **kwargs):  # noqa: E501
        """Retrieves a specific connection flow record from the Agent's database based on its unique `connectionId`.  # noqa: E501

         Retrieve a specific connection flow record from the Agent's database based in its unique `connectionId`. The returned item includes essential metadata such as connection ID, thread ID, state, role, participant information, and other relevant details.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_connection(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_id: The `connectionId` uniquely identifying the connection flow record. (required)
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_connection_with_http_info(connection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_connection_with_http_info(connection_id, **kwargs)  # noqa: E501
            return data

    def get_connection_with_http_info(self, connection_id, **kwargs):  # noqa: E501
        """Retrieves a specific connection flow record from the Agent's database based on its unique `connectionId`.  # noqa: E501

         Retrieve a specific connection flow record from the Agent's database based in its unique `connectionId`. The returned item includes essential metadata such as connection ID, thread ID, state, role, participant information, and other relevant details.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_connection_with_http_info(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connection_id: The `connectionId` uniquely identifying the connection flow record. (required)
        :return: Connection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connection_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_connection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connection_id' is set
        if ('connection_id' not in params or
                params['connection_id'] is None):
            raise ValueError("Missing the required parameter `connection_id` when calling `get_connection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in params:
            path_params['connectionId'] = params['connection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyAuth', 'jwtAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connections/{connectionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Connection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_connections(self, **kwargs):  # noqa: E501
        """Retrieves the list of connection flow records available from the Agent's database.  # noqa: E501

         Retrieve of a list containing connections available from the Agent's database. The API returns a comprehensive collection of connection flow records within the system, regardless of their state. Each connection item includes essential metadata such as connection ID, thread ID, state, role, participant information, and other relevant details. Pagination support is available, allowing for efficient handling of large datasets.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_connections(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int offset: The number of items to skip before returning results. Default is 0 if not specified.
        :param int limit: The maximum number of items to return. Defaults to 100 if not specified.
        :param str thid: The `thid`, shared between the inviter and the invitee, that uniquely identifies a connection flow.
        :return: ConnectionsPage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_connections_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_connections_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_connections_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves the list of connection flow records available from the Agent's database.  # noqa: E501

         Retrieve of a list containing connections available from the Agent's database. The API returns a comprehensive collection of connection flow records within the system, regardless of their state. Each connection item includes essential metadata such as connection ID, thread ID, state, role, participant information, and other relevant details. Pagination support is available, allowing for efficient handling of large datasets.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_connections_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int offset: The number of items to skip before returning results. Default is 0 if not specified.
        :param int limit: The maximum number of items to return. Defaults to 100 if not specified.
        :param str thid: The `thid`, shared between the inviter and the invitee, that uniquely identifies a connection flow.
        :return: ConnectionsPage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['offset', 'limit', 'thid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_connections" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'thid' in params:
            query_params.append(('thid', params['thid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyAuth', 'jwtAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectionsPage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
